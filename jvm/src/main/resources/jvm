类的加载：
    加载-->链接(验证、准备、解析)-->初始化
类的加载器：
    引导类加载器-->启动类加载器（Bootstrap ClassLoader）,用来加载java核心的类库，不继承ClassLoader,没有父加载器;
              加载扩展类和应用程序加载器，并指定为他们的父类。
    扩展类加载器-->(Extension ClassLoader)父类为启动类加载器，主要识别加载jre/lib/ext目录
    系统类加载器-->应用程序类加载器(AppClassloader)父类为扩展类加载器；主要加载自定义的类
双亲委派机制：
    java虚拟机对class文件采用的是按需加载的方式，也就是说放需要使用该类时才会将它的class文件加载到内存生成class对象，
    而且加载某个类的class文件时，java虚拟机采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式。
  优势：
    1、避免类的重复加载
    2、保护程序安全，防止核心API被随意篡改
        例如：自定义一个java.lang.String，加载时运行main方法报错：在类java.lang.String中找不到main方法
  沙箱安全机制：
        自定义的java.lang.String，在加载时会率先使用引导类加载器进行加载，而引导类加载器在加载的过程中会
      加载jdk自带的文件，报错信息说没有main方法就是因为加载了jdk下rt.jar宝中的String类，这样可以保证
      对java核心源代码的保护，这就是沙箱安全机制。
在JVM中表示两个class对象是否为同一个类存在的两个必要条件：
    ☛ 类的完整类名必须一致，包括包名；
    ☛ 加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。
java程序对类的使用方式分为：主动使用和被动使用
    主动使用：
        创建类的实例；
        访问某个类或者接口的静态变量，或者对静态变量赋值；
        调用类的静态方法；
        反射；
        初始化一个类的子类；
        java虚拟机启动时别标明为启动类的类；
        JDK7开始提供的动态语言支持；
     除了以上7种情况，其他使用Java类的方式都被看作是类的被动使用，都不会导致类的初始化。
运行时数据区:
    一个进程：一个方法区，一个堆
    一个进程中多个线程：多个程序计数器，多个本地方法栈，多个虚拟机栈，多个线程共享一个方法区和堆
在Hotspot JVM中，每个线程都有操作系统的本地线程直接映射。
    ☛ 在一个Java线程准备执行以后，此时操作系统的本地线程也同时创建，Java线程终止之后，本地线程也会回收。
操作系统负责所有线程的安排调度到任何一个可用的CPU上，一旦本地线程初始化完毕，他就会代用Java线程中的run()方法执行。
程序计数器(PC寄存器)：既没有GC垃圾回收，也不会发生OOM(内存溢出)
    用来存储指向下一条指令的地址，他即将要执行的额指令代码，由执行引擎读取下一条指令。




